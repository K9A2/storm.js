---
title: 深入理解 JVM - Java 内存管理
tag: 深入理解 JVM, Memory
date: 2019-04-02
description: Java 模型与管理
---

# Java 内存模型与管理

## 1. 内存模型与垃圾回收

### 1.1 JVM 的内存模型中包含以下部分

1. 程序计数器 (Program Counter, PC). 每个线程都有一个独立的程序计数器. 切换线程时需要保证能够恢复到原来的执行位置就靠保存当前 PC 的值. 执行 Java 方法是 PC 有值, 执行 Native 方法是 PC 为 Undefined.
2. 虚拟机栈 (VM Stack), 生命周期同线程生命周期. 每线程一个. 储存局部变量, 操作站, 动态链接等数据. 栈深度大于虚拟机所允许的深度, 则报 StackOverFlowError 错误. 无法申请到足够的内存以存放栈中数据时报 OutOfMemoryError 错误.
3. 本地方法栈 (Native Method Stack) 保存本地方法.
4. 堆 (Heap). 被所有线程共享, 在虚拟机启动时被创建. 用于存放对象实例. 是 GC 的主要区域. 可以是物理上不连续的空间.
5. 方法区 (Method Area). 多线程共享. 存放被加载的类信息, 常亮, 静态变量等. 较少进行 GC.
6. 运行常亮池 (Runtime Constant Pool), 存放编译期生成的各种字面量和符号引用. 类加载后放入.
7. 直接内存 (Direct Memory). 可导致 OOM 错误

![JVM 内存模型](http://www.ityouknow.com/assets/images/2017/jvm/structure.png)

### 1.2 对象访问的方式

通过类引用 (reference) 访问对象, 但 reference 的实现方式有以下几种方式:

1. 句柄访问: reference 获得分别指向对象实例和对象类型的指针. 在移动对象是无需改变 reference.
2. 直接指针访问: reference 获得指向对象实例的指针. 此指针内部包含到对象类型的指针.只需要一次指针访问, 速度快.

### 1.3 内存调优的大概思路

1. 是内存泄露还是内存溢出?
2. 调整虚拟机堆参数 (-Xmx 和 -Xms)
3. 从代码上调整某些生命周期过长的对象


## 2. 内存分配与回收策略

自动内存管理的任务：给对象分配内存，回收分配给对象的内存。  
Minor GC：针对新生代的 GC。频繁发生，速度较快。  
Major GC/Full GC：针对老年代的 GC。速度较慢。  

内存分配策略

1. 对象优先在 Eden 区域分配。当 Eden 区域没有足够的空间时，将导致 Minor GC。
2. 大量需要连续内存空间的对象进入老年代。可以通过设置 PretenureSizeThreshold 参数使得超过此值得对象直接在老年代中分配，以避免在 Eden 区和 Survivor 区中发生大量的内存复制操作。
3. 长期存活的对象进入老年代。给对象设置年龄。在 Eden 出生并通过第一次 Minor GC 之后仍存活且能被 Survivor 容纳，则进入 Survivor 区并获得年龄 1。以后每次 Minor GC 都会使 Age 加一。当 Age > 15 时，对象进入老年代。
4. 动态对象年龄判定。如果 Survivor 空间中所有相同年龄的对象大小总和超过 Survivor 空间的一半，则把年龄大于等于该年龄的对象放入老年代。

## 3. 垃圾回收的基本概念

### 3.1 确定对象是否死亡的方法

1. 引用计数法: 实现简单效率高, 但无法解决循环引用问题.
2. 根搜索算法: 以 GC Roots 对象为起点, 自顶向下搜索. 走过的路径称为引用链. 当一个对象到 GC Roots 时无引用链, 则认为此对象不可达.

引用的强度: 强引用 (Strong) > 软引用 (Soft) > 弱引用 (Weak) > 许引用 (Phantom).

1. 强引用不会导致 GC
2. 软引用, 有用但非必须对象. 发生 OOM 前回收.
3. 弱引用, 生命周期到下次 GC.
4. 虚引用, 不会影响生命周期.

### 3.2 永久代回收

回收的主要内容包括：废弃常亮和无用的类（无实例、加载该类的 ClassLoader 以被回收、java.lang.Class 对象没有任何引用切勿反射访问该类的方法）。频繁自定义 ClassLoader 的场景需要具备类卸载功能，以确保永久代不会溢出。

## 4. 垃圾回收

基本的垃圾回收算法有以下几种

1. 复制-收集算法。新生代使用。将可用内存按容量花费为大小相等的两块，每次只使用其中一块；当这一块的空间用完了，就把其中存活的对象复制到另一块上，然后把此块回收。缺点是可用内存减半；优点是简单高效。常用此法回收新生代。内存划分为较大的 Eden 空间和两块较小的 Survivor 空间。每次使用 Eden 空间和一个 Survivor 空间，并进行垃圾回收。当存活对象较多的时候，需要大量复制操作。
2. 标记-清除算法。老年代使用。首先标记出需要回收的对象，标记完成后统一回收。此方法效率低；产生大量内存碎片。
3. 标记-整理算法。老年代使用。让所有存活的对象向内存空间的一端移动，然后回收端边界以外的内存。
4. 分代回收。把内存空间分成新生代和老年代。根据每个年代的特点采用合适的算法。

垃圾回收器的种类

1. Serial 收集器。单线程。会导致 Stop the world 事件发生。即停掉所有线程进行垃圾回收。简单高效，单线程回收效率高。
2. ParNew 收集器。Serial 收集器的多线程版本。Server 模式下的虚拟机的首选新生代垃圾收集器。
3. Parallel Scavenge 收集器。新生代收集器。使用复制算法。着重于吞吐量，即实际运行时间与总时间的比值。适合后台计算程序使用。
4. Serial Old 收集器。单线程。使用标记整理算法。适合老年代使用
5. Parallel Old 收集器。Parallel Scavenge 收集器的老年代版本。使用多线程和标记整理算法。
6. CMS （Concurrent Mark Sweep）收集器。以获取最小停顿时间为目的。使用标记清除算法。整个垃圾收集步骤分为
   + 初始标记（initial mark），stop the world，标记 GC roots 能够直接关联到的对象
   + 并发标记 （concurrent mark），stop the world，并行 GC roots tracing 的过程
   + 重新标记（remark），修正并发标记期间所产生的标记变动
   + 并发清除（concurrent sweep）  
缺点：
   + 对 CPU 资源十分敏感。低 CPU 数时会影响用户体验。
   + 无法处理浮动垃圾。CMS 无法在本次 GC 中收集新的垃圾。如果无法预留足够的空间给用户线程使用。则导致 Concurrent  Mode Failure 失败。进而使得 JVM 调用 Serial 收集器进行 Full GC 的停顿。
   + 可能在老年代空间中产生大量内存碎片。
7. G1 收集器。基于标记-整理算法。优点：
   + 基于标记-整理算法，不产生碎片
   + 可以精确控制 GC 停顿时间  

把整个 Java 堆（包括新生代老年代）划分为多个固定大小的独立区域（Region）。维护优先列表。每次根据允许的 GC 时间回收垃圾最多的区域。

## 内存使用探查常用命令

jps 获取 jvm 中所有进程的 pid

jmap -heap pid 获取指定进程的堆栈信息
jmap -histo pid | head -n 20 查看堆栈中对象数量和大小, 仅输出前 20 名

jstack 查看进程堆栈, 分析进程停顿原因

jstat -gc pid 5000 20 检测进程分代内存使用情况, 每 5000 毫秒统计一次, 一共 20 次
jstat -gcutil pid 5000 20 检测进程分代内存使用率和 GC 情况

jinfo option-name pid 查看进程的 jvm 参数

jconsole 可视化检测工具
