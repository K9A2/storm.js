<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <link rel="SHORTCUT ICON" href="./img/icon.jpg">

    <title>文章内容</title>

    <link rel="stylesheet" href="css/deploy.min.css">

    <script src="js/jquery.min.js"></script>
    <script src="js/highlight.min.js"></script>
    <script src="js/custom.min.js"></script>

</head>

<body>

    <div class="nav">
    <div class="container">
        <div class="icon">
            <a href="./index.html">
                <img id="avatar" src="img/icon.jpg">
            </a>
        </div>
        <div class="list">
            <ul class="nav-list">
                <li class="nav-list-item">
                    <a href="./index.html">首页</a>
                </li>
                <li class="nav-list-item">
                    <a href="./about.html">关于我</a>
                </li>
                <li class="nav-list-item">
                    <a href="http://u4813096.viewer.maka.im/k/OQHMX6E6?from=timeline">狗粮合集</a>
                </li>
            </ul>
        </div>
    </div>
</div>

    <div class="title">
        <div class="container">
            <h1>storm.js 开发总结</h1>
            <p>日期：2017-01-01</p>
            <div class="tags">标签：<a href="/tag.html?tag=javascript">javascript</a><a href="/tag.html?tag=Developer">Developer</a><a href="/tag.html?tag=summary">summary</a></div>
        </div>
    </div>

    <div class="container postContainer">
        <div class="leftCol">
            <div id="author">
                <div id="avatar">
                    <img src="./img/icon.jpg">
                </div>
                <div id="name">
                    <a href="./about.html" title="关于我">stormlin</a>
                </div>
                <div class="contactList">
                    <div class="contact">
                        <a href="https://github.com/K9A2" target="_blank">
                            <img src="./img/GitHub.png" alt="前往我的 GitHub" title="前往我的 GitHub">
                        </a>
                    </div>
                    <div class="contact">
                        <a href="http://blog.csdn.net/atmiao" target="_blank" title="前往我的 CSDN 博客">
                            <img src="./img/csdn.png" alt="前往我的 CSDN 博客">
                        </a>
                    </div>
                    <div class="contact">
                        <a href="mailto:lin-jinting@outlook.com" target="_blank" title="给我发一封邮件">
                            <img src="./img/mail.png" alt="给我发一封邮件">
                        </a>
                    </div>
                </div>
            </div>
            <div id="toc">
            </div>
        </div>
        <div class="rightCol">
            <div id="warning">
    <span>本文章已经发表超过一年，其中部分内容可能已过时，请注意</span>
</div>
            <div id="main">
                <div id="content">
                    <article class="markdown-body">
                        <!-- storm.js 开发总结 -->
<p>storm.js 是一种轻量级的 js 博客系统。下面是一些在开发它时所遇到的一些要点和坑点，分享给大家。</p>
<h2 id="1-javascript-">1. Javascript的执行顺序</h2>
<p>storm.js 的下的 index.html 里面有这么一段代码：</p>
<pre><code class="lang-html">&lt;!-- 代码段一 --&gt;
&lt;script&gt;
    $.get(&quot;./md/index.md&quot;).success(function (content) {
        $(&quot;.markdown-body&quot;).append(marked(content));
        $(&quot;pre&quot;).addClass(&quot;prettyprint linenums&quot;);
        $(&quot;title&quot;).html($(&quot;h1&quot;).html());
        $(&quot;a&quot;).attr(&quot;target&quot;, &quot;_blank&quot;);
    });
&lt;/script&gt;
</code></pre>
<p>代码段一中的第 5 行负责获取这个 markdown 文档中的 h1，并把页面 title 设定为这个 h1；第 6 行负责给页面内所有的链接加上在新一页打开的功能（即 target=&quot;_blank&quot;）。这两行原来在整个 index.html 的底部，设想由它们两段代码对第 4 行、第 5 行渲染后的 html 文件进行 DOM 操作。而代码段二则是原来的代码块。</p>
<pre><code class="lang-html">&lt;!-- 代码段二 --&gt;
&lt;script&gt;
    $.get(&quot;./md/index.md&quot;).success(function (content) {
        $(&quot;.markdown-body&quot;).append(marked(content));
        $(&quot;pre&quot;).addClass(&quot;prettyprint linenums&quot;);
    });
&lt;/script&gt;
</code></pre>
<p>由于在调试的时候，用 <code>alert($(&quot;h1&quot;).html())</code> 无法获取到渲染后的 h1，所以也就不能设定 title 的值了。故转而考虑到是否是页面内的 JavaScript 代码执行顺序出了问题。Google 后获得以下结果<em>（为什么这么重要的内容在 JavaScript 权威指南里面没有呢？）</em>：</p>
<ul>
<li><p><strong>浏览器在加载 html 文档是会会把这个 html 文档当成文档流来处理。对于其中的 JavaScript 代码块会按照顺序以块为单位执行</strong>：</p>
<pre><code class="lang-javascript">&lt;script&gt;
    alert(&quot;block 1&quot;);
&lt;/script&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script&gt;
            alert(&quot;block 2&quot;);
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script&gt;
            alert(&quot;block 3&quot;);
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
&lt;script&gt;
    alert(&quot;block 4&quot;);
&lt;/script&gt;
</code></pre>
<p>执行顺序为 1 -&gt; 2 -&gt; 3 -&gt; 4。</p>
</li>
<li><p><strong>JavaScript 引擎会也并非完全按照顺序来执行代码。在解释之前，引擎会对代码进行一次预编译。定义式函数会被优先执行，赋值式函数在用的时候才会处理</strong>：</p>
<pre><code class="lang-javascript">&lt;script&gt;
    &quot;use strict&quot;

    function Hello() {
        alert(&quot;Hello&quot;);
    }
    Hello();

    function Hello() {
        alert(&quot;Hello World&quot;);
    }
    Hello();
&lt;/script&gt;
</code></pre>
<p>以上的代码块中，并不会出现 <em>Hello</em> 和 <em>Hello World</em>。而是两次 <em>Hello World</em>。</p>
<p>在解析之前，JavaScript 引擎会对 html 文档进行一次<strong>预编译</strong>操作。在此过程中，<strong>定义式的函数会被优先执行</strong>，各种 var 变量也会被创建并赋值为 undefined：</p>
<pre><code class="lang-javascript">&lt;script&gt;
    var Hello = function() {           
        alert(&quot;Hello&quot;);        
    }

    Hello = function() { 
        alert(&quot;Hello World&quot;);  
    }  

    Hello();     
    Hello();
&lt;/script&gt;
</code></pre>
<p>而要防止两个 <em>Hello</em> 函数被 JavaScript 引擎优化掉，可以把他们分别放到两个代码块中。</p>
<p>定义式函数与赋值式函数：</p>
<pre><code class="lang-javascript">&lt;script&gt;
    //定义式函数
    function fun1() {
        alert(&quot;fun1&quot;);
    }
    fun1();    

    //赋值式函数
    Fun2();
    var Fun2 = function() {
        alert(&quot;fun2&quot;);
    }
&lt;/script&gt;
</code></pre>
<p>如果这么写，那在 Chrome 的 Console 就能看到：<em>Uncaught TypeError: Fun2 is not a function</em> 的警告了。</p>
<p>如果把 fun1() 写到其定义之上，那么受到<strong>函数提升</strong>的作用，也是能执行的，浏览器不会报错，无论是否处在<strong>严格模式（&quot;use strict&quot;）</strong>之下</p>
</li>
<li><p><strong>使用 document.wirte() 来输出 JavaScript 脚本，那么浏览器会在加载完所有 document.wirte() 之后再解析 html 文档：</strong></p>
<pre><code class="lang-javascript">document.write(&#39;&lt;script type=&quot;text/javascript&quot;&gt;&#39;);
document.write(&#39;f();&#39;);
document.write(&#39;function f(){&#39;);
document.write(&#39;alert(1);&#39;);
document.write(&#39;}&#39;);
document.write(&#39;&lt;/script&gt;&#39;);
</code></pre>
<p>等价于：</p>
<pre><code class="lang-javascript">&lt;script&gt;
    f();
    function f() {
        alert(1);
    }
&lt;/script&gt;
</code></pre>
</li>
<li><p><strong>如果一个 html 页面中有多个 <em>window.onload</em> 事件处理函数，那么会按照顺序执行：</strong></p>
<pre><code class="lang-javascript">&lt;script&gt;
    &quot;use strict&quot;

    function fun1() {
        alert(&quot;fun1&quot;);
    }

    function fun2() {
        alert(&quot;fun2&quot;);
    }
    window.onload = fun1();
    window.onload = fun2();
&lt;/script&gt;
</code></pre>
</li>
<li><p><strong>重复定义函数会覆盖掉前面定义的函数：</strong></p>
<pre><code class="lang-javascript">&lt;script&gt;
    &quot;use strict&quot;

    function fun1() {
        alert(&quot;fun1&quot;);
    }

    function fun1() {
        alert(&quot;fun2&quot;);
    }
    fun1();
&lt;/script&gt;
</code></pre>
<p>其中，后面的 fun1 会覆盖掉前面的 fun1，运行结果为 <em>alert(&quot;fun2&quot;);</em>。</p>
</li>
<li><p><strong>body 的 onload 是在 html 加载完成后发生，故其顺序在 body 里面的 JavaScript 代码之后：</strong></p>
<pre><code class="lang-html">&lt;body onload=&quot;fun1()&quot;&gt;

&lt;script&gt;
    &quot;use strict&quot;

    function fun1() {
        alert(&quot;fun1&quot;);
    }

    function fun2() {
        alert(&quot;fun2&quot;);
    }
    fun2();
&lt;/script&gt;

&lt;/body&gt;
</code></pre>
<p>fun2() 会先于 fun1() 被执行。</p>
</li>
</ul>
<h2 id="2-jquery-markdown-">2. 使用 jQuery 读取本地 markdown 文档</h2>
<pre><code class="lang-javascript">&lt;script&gt;
$.get(url).success().error();
&lt;/script&gt;
</code></pre>
<p>以上是本项目中用到的 jQuery get 方法。其中 success 填入操作成功时的回调函数，error 填入操作失败是的回调函数。</p>
<p>官方参考文档：<a href="http://jquery.cuishifeng.cn/jQuery.get.html">http://jquery.cuishifeng.cn/jQuery.get.html</a>。</p>
<p><em>但是，这个方法有个很大的问题：当要获取的文件的文件名中含有 <strong>.</strong> 时会出错。例如获取 <strong>storm.js.md</strong> 或出错。如第一点中的代码段一，会先执行 success 中的内容再执行 error 中的内容。目前此问题已经到 jQuery 的 GitHub 上提交 issue，等待对方处理。</em></p>
<h2 id="3-">3. 为移动设备放大字体</h2>
<p>目前有两种方法：</p>
<ul>
<li>使用 CSS3 中的 <strong>@media 查询</strong>来获取客户机的分辨率，以动态地调整客户机浏览器上的字体大小；</li>
<li>使用 js 代码进行动态计算并用 DOM 操作来改变字体大小。</li>
</ul>
<p>显然，方法二的性能损失比方法一要大；而且方法一有现成的 API 可用，何乐而不为？</p>
<p>下面是一些我为小米四上的 Chrome 和 Firefox 调整过的 CSS 样式，大家可以参考：</p>
<pre><code class="lang-css">/* 屏幕最小分辨率为 320 px 的设备 */
@media screen and (min-width: 320px) {
    html {font-size: 26px;}
    article {
        margin: auto 15px auto 15px;
    }
    body {
        width: 100%;
        margin-left: 0;
        margin-right: 0;
        border: none;
    }
}

/* 屏幕最小分辨率为 360 px 的设备 */
@media screen and (min-width: 360px) {
    html {font-size: 28px;}
    article {
        margin: auto 15px auto 15px;
    }
    body {
        width: 100%;
        margin-left: 0;
        margin-right: 0;
        border: none;
    }
}

/* 屏幕最小分辨率为 400 px 的设备 */
@media screen and (min-width: 400px) {
    html {font-size: 30px;}
    article {
        margin: auto 15px auto 15px;
    }
    body {
        width: 100%;
        margin-left: 0;
        margin-right: 0;
        border: none;
    }
}

/* 屏幕最小分辨率为 440 px 的设备 */
@media screen and (min-width: 440px) {
    html {font-size: 32px;}
    article {
        margin: auto 15px auto 15px;
    }
    body {
        width: 100%;
        margin-left: 0;
        margin-right: 0;
        border: none;
    }
}

/* 屏幕最小分辨率为 480 px 的设备 */
@media screen and (min-width: 480px) {
    html {font-size: 34px;}
    article {
        margin: auto 15px auto 15px;
    }
    body {
        width: 100%;
        margin-left: 0;
        margin-right: 0;
        border: none;
    }
}

/* 屏幕最小分辨率为 640 px 的设备 */
@media screen and (min-width: 640px) {
    html {font-size: 40px;}
    article {
        margin: auto 15px auto 15px;
    }
    body {
        width: 100%;
        margin-left: 0;
        margin-right: 0;
        border: none;
    }
}

/* 屏幕最小分辨率为 1080 px 的设备 */
@media screen and (min-width: 1080px) {
    html {
        font-size: 16px;
    }
    body {
        margin: 5% auto;
        width: 60%;
        border: none;
        border: 1px solid #ddd;
    }
}

/* 默认大小，适配 PC 页面 */
body {
    border-radius: 3px;
    padding: 3% 3% 3% 3%;
    font-size: 16px;
}
</code></pre>
<h2 id="4-chrome-">4. 使用 Chrome 来调试移动设备上的网页</h2>
<p>有些时候，我们需要查看一下移动设备上的网页的具体情况。但是移动端浏览器一般没有 Chrome 的 Inspect 功能，所以需要借助 PC 端的 Chrome 来“代理”一下：</p>
<ol>
<li>PC 端以及 Android 端安装最新的 Chrome 浏览器；</li>
<li>Android 端打开 Debug 模式，并用 USB 线连接到 PC 上；</li>
<li>在 PC 端的 Chrome 浏览器的地址框中输入：<strong>chrome://inspect</strong>，即可看到自己的 Android 设备；</li>
<li>在刚才的页面中点击 Inspect 即可。</li>
</ol>
<p><em>注意：在点击 Inspect 之后弹出空白页面，请打开 VPN。</em></p>
<p><em>参考资料：<a href="http://www.cnblogs.com/alantao/p/5220392.html">移动前端调试方案（Android + Chrome 实现远程调试）</a>。</em></p>

                    </article>
                </div>
            </div>
        </div>
    </div>

    <div id='toTop' title="返回顶部">
        <div class="arrow"></div>
        <div class="stick"></div>
    </div>

    <script>
        // 用以去除写作 Markdown 文档中自然留下的一级标题
        var fileHeader = $("#content").find("h1");
        fileHeader.remove();

        // 生成文章目录
        getTOC();

        // 代码高亮
        hljs.initHighlightingOnLoad();
    </script>

    <div class="footer">
    <p>Copyright © 2014 - 2018 stormlin.</p>
    <p>All Rights Reserved.</p>
    <p>
        <a href="http://www.miitbeian.gov.cn">备案号：粤ICP备16029958号-1</a>
    </p>
</div>

</body>

</html>