---
title: Java 基础 - volatile 与 synchronized 的区别
date: 2019-04-02
tag: Java, Concurrency
description: Java 基础 - volatile 与 synchronized 的区别
---

# Java 基础 - volatile 与 synchronized 

## 1. 基本概念

以一个变量为例, 由于每个 Java 线程都有自己的私有内存, 并且线程在读取这个变量的时候会优先从私有内存中读取而非从主内存中读取. 故在多线程环境中, 若某个变量的值被改变, 并且这个变量没有被 volatile 修饰, 则其他线程在读取这个变量的时候就不保证能够读到最新的值. 而使用 volatile 关键字则可以保证此变量被改变后, 任何一个读它的线程都能读到最新的值 (最新的值被刷新到主存).

![jvm 内存模型简图](http://ifeve.com/wp-content/uploads/2013/01/113.png)

除此之外, 被 volatile 修饰的变量不会被编译器进行指令重排操作, 则能够在多线程环境中提供一定的同步性. 程序执行到volatile修饰变量的读操作或者写操作时，在其前面的操作肯定已经完成，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行。

> 指令重排是指处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证各个语句的执行顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。

另外, volatile 无原子性, 可被其他进程中断. 而且, volatile 只能用来修饰变量.

synchronized 修饰的内容可包括对象, 变量, 方法, 类等. 被 synchronized 修饰的内容在所有进程间都是互斥的, 访问前会对访问对象加锁, 访问后会把此对象的值刷新到主内存中. 其他进程则会被阻塞到此进程释放锁. synchronized 具有原子性. 然而, synchronized 会带来很大的性能开销.

## 2. 可重入性

> 若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。

被 synchronized 锁住的对象会在对象上添加锁计数器, 每一个锁住它的进程使计数器 +1, 每一个释放锁的进程使计数器 -1. 计数器为零的时候, JVM 对该变量解锁.
